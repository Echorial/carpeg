class CarpegNativeParserLocation {
bound public int offset = 0;
bound public int line = 1;
bound public int column = 0;
fixed public <CarpegNativeParserLocation>function @construct(int offset, int line, int column) {
this.offset = offset; this.line = line; this.column = column;
}
}

class CarpegNativeParserError inherits CarpegNativeParserLocation {
bound public int code = 0;
bound public string found = 0;
bound public string expected = 0;
bound public int vested = 0;
bound public <CarpegNativeParserError>array path = new <CarpegNativeParserError>array();
bound public <CarpegNativeParserError>function clone() {var CarpegNativeParserError clone = new CarpegNativeParserError(this.offset, this.line, this.column); clone.code = this.code; clone.found = this.found; clone.expected = this.expected; clone.vested = this.vested; for (var int i in this.path) {var CarpegNativeParserError current = this.path[i]; clone.path.push(current.clone());} return clone;}}

class <class T>CarpegNativeParserOutput {
	fixed public <void>function @construct(bool hadError, CarpegNativeParserError error, map data) {this.hadError = hadError; this.error = error; this.data = data;}
	bound public CarpegNativeParserError error = empty;
	bound public bool hadError = false;
	bound public map data = new map();
}
class CarpegNativeParser inherits CarpegNativeParserLocation {
fixed public override <CarpegNativeParser>function @construct() {}
fixed public <<map>CarpegNativeParserOutput>function parse(string input) {	var <map>CarpegNativeParser parser = new <map>CarpegNativeParser();
	var map output = parser.start(input);
	if (parser.hadError and (parser.error.found == string.fromCharCode(0001))) {
		parser.error.found = "End of input";
}
	var <map>CarpegNativeParserOutput rtn = new <map>CarpegNativeParserOutput(parser.hadError, parser.error, parser.data["data"]);
	return rtn;
}
bound public <CarpegNativeParserError>array lastErrors = new <CarpegNativeParserError>array();
bound public bool hadError = false;
bound public int parsedChars = 0;
bound public string currentInput = new string();
bound public map data = new map();
bound public CarpegNativeParserError error = new CarpegNativeParserError(0, 0, 0);
bound public <string>function assembleCodes(<int>array codes) {
	var string rtn = new string();
	for (var int i in codes) {
		rtn += string.fromCharCode(codes[i]);
	}
	return rtn;}
bound public <void>function giveError(int code, string expected, string found) {
this.hadError = true;
this.error.code = code;
this.error.expected = expected;
this.error.found = found;
this.error.offset = this.offset;
this.error.line = 1;
this.error.column = 0;
}

bound public <map>function start(string input) {
	this.currentInput = input;
	input += string.fromCharCode(0001);	this.data["data"] = new map();
	var map data = this.data["data"];
	var int c = 0;
	
			var int literalChar = 0;
	for (var int charPos = 0; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (c == 0 - 1) {if (currentChar != string.fromCharCode(0001)) {this.giveError(2, "EOF", currentChar);}}
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <map>CarpegNativeParserOutput ruleOut0 = this.Grammar(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "Grammar(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var map ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		data["parsed"] = ruleOutCast0;
		c = 0 - 1;
		this.error.vested++;
	}
}		this.offset++; 
 this.column++;
		if (this.hadError) {break;}
	}
	for (var int i = 0; i < this.error.offset; i++) {
		this.error.column++;
		if (this.currentInput[i] == "\n") {this.error.line++; this.error.column = 0;}
	}
	if (false and this.hadError == false) {
		if (this.offset < input.length() - 1) {
			this.giveError(2, "EOF", input[this.offset + 1]);		}
	}
}
bound public <<string>CarpegNativeParserOutput>function Comment(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new string();
dataStore["temp"] = new map();
	var string data = dataStore["temp"];
	var int c = 0;
	

data = new string();

			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <string>CarpegNativeParserOutput ruleOut0 = this._(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "White space(optional)(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var string ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		
		c = 1;
		
	}
}else if (c == 1) {
	var <int>array lit1 = [47, 47];
	if (currentCode == lit1[literalChar]) {
		literalChar++;
		if (literalChar == 2) {
			
			c = 2;
			literalChar = 0;
}
			this.error.vested++;
	}else{
		this.giveError(1, "" + this.assembleCodes(lit1) + "", currentChar);
	}
}else if (c == 2) {
	var bool passed2 = false;
	if (currentCode == 10) {passed2 = true;}
	if (passed2 == false) {
		
	}
	if (passed2) {
		c = 0 - 1; charPos--; this.offset--;		this.error.vested++;

	}else{
		
c = 2;
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <string>CarpegNativeParserOutput parseOutput = new <string>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Grammar(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	data["imports"] = new <map>array();


data["rules"] = new <map>array();


			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <map>CarpegNativeParserOutput ruleOut0 = this.Importer(input, charPos);
	
if (ruleOut0.hadError) {
		c = 1; charPos--; this.offset--;
		if (ruleOut0.error.vested > 1) {this.giveError(ruleOut0.error.code, ruleOut0.error.expected, ruleOut0.error.found);}
	}else{
		var map ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		var <map>array castimports0 = data["imports"];
castimports0.push(ruleOutCast0);
if (charPos == input.length() - 1) {this.giveError(2, "EOF", currentChar);}

		c = 0;
		this.error.vested++;
	}
}else if (c == 1) {
	var <string>CarpegNativeParserOutput ruleOut1 = this._(input, charPos);
	
if (ruleOut1.hadError) {
		this.giveError(ruleOut1.error.code, "White space(optional)(" + ruleOut1.error.expected + ")", ruleOut1.error.found);
		
	}else{
		var string ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		
		c = 2;
		
	}
}else if (c == 2) {
	var <map>CarpegNativeParserOutput ruleOut2 = this.Rule(input, charPos);
	
if (ruleOut2.hadError) {
		c = 3; charPos--; this.offset--;
		if (ruleOut2.error.vested > 1) {this.giveError(ruleOut2.error.code, ruleOut2.error.expected, ruleOut2.error.found);}
	}else{
		var map ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		var <map>array castrules2 = data["rules"];
castrules2.push(ruleOutCast2);

		c = 2;
		this.error.vested++;
	}
}else if (c == 3) {
	var <string>CarpegNativeParserOutput ruleOut3 = this._(input, charPos);
	
if (ruleOut3.hadError) {
		this.giveError(ruleOut3.error.code, "White space(optional)(" + ruleOut3.error.expected + ")", ruleOut3.error.found);
		
	}else{
		var string ruleOutCast3 = ruleOut3.data["data"];
charPos = this.offset;
		if (true) {

var string castac3 = data[""];
var <map>array actionCap3imports = data["imports"];var <map>array actionCap3rules = data["rules"];dataStore["data"]["imports"] = actionCap3imports;
dataStore["data"]["rules"] = actionCap3rules;
}
		c = 0 - 1;
		
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Importer(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	



			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <int>array lit0 = [105, 109, 112, 111, 114, 116];
	if (currentCode == lit0[literalChar]) {
		literalChar++;
		if (literalChar == 6) {
			
			c = 1;
			literalChar = 0;
}
			this.error.vested++;
	}else{
		this.giveError(1, "" + this.assembleCodes(lit0) + "", currentChar);
	}
}else if (c == 1) {
	var <string>CarpegNativeParserOutput ruleOut1 = this.__(input, charPos);
	
if (ruleOut1.hadError) {
		this.giveError(ruleOut1.error.code, "White space(" + ruleOut1.error.expected + ")", ruleOut1.error.found);
		
	}else{
		var string ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		
		c = 2;
		
	}
}else if (c == 2) {
	var <string>CarpegNativeParserOutput ruleOut2 = this.Safe_Name(input, charPos);
	
if (ruleOut2.hadError) {
		this.giveError(ruleOut2.error.code, "Safe_Name(" + ruleOut2.error.expected + ")", ruleOut2.error.found);
		
	}else{
		var string ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		data["name"] = ruleOutCast2;
		c = 3;
		
	}
}else if (c == 3) {
	var <string>CarpegNativeParserOutput ruleOut3 = this._(input, charPos);
	
if (ruleOut3.hadError) {
		this.giveError(ruleOut3.error.code, "White space(optional)(" + ruleOut3.error.expected + ")", ruleOut3.error.found);
		
	}else{
		var string ruleOutCast3 = ruleOut3.data["data"];
charPos = this.offset;
		if (true) {

var string castac3 = data[""];
var string actionCap3name = data["name"];dataStore["data"]["name"] = actionCap3name;
}
		c = 0 - 1;
		
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<string>CarpegNativeParserOutput>function Safe_Name(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new string();
dataStore["temp"] = new map();
	var string data = dataStore["temp"];
	var int c = 0;
	data["str"] = new string();

			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var bool passed0 = false;
	if (currentCode == 95) {passed0 = true;}
	if (passed0 == false) {
		if (int.mid(currentCode, 65, 90)) {passed0 = true;}else if (int.mid(currentCode, 97, 122)) {passed0 = true;}else if (int.mid(currentCode, 48, 57)) {passed0 = true;}
	}
	if (passed0) {
		data["str"] += currentChar;
if (true) {

var string castacstr0 = data["str"];
var string actionCap0str = data["str"];dataStore["data"] = actionCap0str;}
c = 0;		this.error.vested++;

	}else{
		var string caststr0 = data["str"];
if (caststr0.length() >= 1) {
if (true) {

var string castacstr0 = data["str"];
var string actionCap0str = data["str"];dataStore["data"] = actionCap0str;}c = 0 - 1; charPos--; this.offset--;}else{
this.giveError(1, "A-Z, a-z, 0-9, _", currentChar);}

	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <string>CarpegNativeParserOutput parseOutput = new <string>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<string>CarpegNativeParserOutput>function Type_Name(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new string();
dataStore["temp"] = new map();
	var string data = dataStore["temp"];
	var int c = 0;
	data["str"] = new string();

			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var bool passed0 = false;
	if (currentCode == 95) {passed0 = true;}else if (currentCode == 62) {passed0 = true;}else if (currentCode == 60) {passed0 = true;}
	if (passed0 == false) {
		if (int.mid(currentCode, 65, 90)) {passed0 = true;}else if (int.mid(currentCode, 97, 122)) {passed0 = true;}else if (int.mid(currentCode, 48, 57)) {passed0 = true;}
	}
	if (passed0) {
		data["str"] += currentChar;
if (true) {

var string castacstr0 = data["str"];
var string actionCap0str = data["str"];dataStore["data"] = actionCap0str;}
c = 0;		this.error.vested++;

	}else{
		var string caststr0 = data["str"];
if (caststr0.length() >= 1) {
if (true) {

var string castacstr0 = data["str"];
var string actionCap0str = data["str"];dataStore["data"] = actionCap0str;}c = 0 - 1; charPos--; this.offset--;}else{
this.giveError(1, "A-Z, a-z, 0-9, _, >, <", currentChar);}

	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <string>CarpegNativeParserOutput parseOutput = new <string>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Rule(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var <string>array data = dataStore["temp"];
	var int c = 0;
	
data = new <string>array();


















			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <string>CarpegNativeParserOutput ruleOut0 = this._(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "White space(optional)(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var string ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		
		c = 1;
		
	}
}else if (c == 1) {
	var <string>CarpegNativeParserOutput ruleOut1 = this.Comment(input, charPos);
	
if (ruleOut1.hadError) {
		c = 2; charPos--; this.offset--;
		if (ruleOut1.error.vested > 1) {this.giveError(ruleOut1.error.code, ruleOut1.error.expected, ruleOut1.error.found);}
	}else{
		var string ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		
		c = 1;
		this.error.vested++;
	}
}else if (c == 2) {
	var <string>CarpegNativeParserOutput ruleOut2 = this._(input, charPos);
	
if (ruleOut2.hadError) {
		this.giveError(ruleOut2.error.code, "White space(optional)(" + ruleOut2.error.expected + ")", ruleOut2.error.found);
		
	}else{
		var string ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		
		c = 3;
		
	}
}else if (c == 3) {
	var <string>CarpegNativeParserOutput ruleOut3 = this.Type_Name(input, charPos);
	
if (ruleOut3.hadError) {
		this.giveError(ruleOut3.error.code, "Type_Name(" + ruleOut3.error.expected + ")", ruleOut3.error.found);
		
	}else{
		var string ruleOutCast3 = ruleOut3.data["data"];
charPos = this.offset;
		data["outputType"] = ruleOutCast3;
		c = 4;
		
	}
}else if (c == 4) {
	var <string>CarpegNativeParserOutput ruleOut4 = this._(input, charPos);
	
if (ruleOut4.hadError) {
		this.giveError(ruleOut4.error.code, "White space(optional)(" + ruleOut4.error.expected + ")", ruleOut4.error.found);
		
	}else{
		var string ruleOutCast4 = ruleOut4.data["data"];
charPos = this.offset;
		
		c = 5;
		
	}
}else if (c == 5) {
	if (currentCode == 124) {
			
			c = 6;
			this.error.vested++;
	}else{
		this.giveError(1, "|", currentChar);
	}
}else if (c == 6) {
	var <string>CarpegNativeParserOutput ruleOut6 = this._(input, charPos);
	
if (ruleOut6.hadError) {
		this.giveError(ruleOut6.error.code, "White space(optional)(" + ruleOut6.error.expected + ")", ruleOut6.error.found);
		
	}else{
		var string ruleOutCast6 = ruleOut6.data["data"];
charPos = this.offset;
		
		c = 7;
		
	}
}else if (c == 7) {
	var <string>CarpegNativeParserOutput ruleOut7 = this.Safe_Name(input, charPos);
	
if (ruleOut7.hadError) {
		this.giveError(ruleOut7.error.code, "Safe_Name(" + ruleOut7.error.expected + ")", ruleOut7.error.found);
		
	}else{
		var string ruleOutCast7 = ruleOut7.data["data"];
charPos = this.offset;
		data["name"] = ruleOutCast7;
		c = 8;
		
	}
}else if (c == 8) {
	var <string>CarpegNativeParserOutput ruleOut8 = this._(input, charPos);
	
if (ruleOut8.hadError) {
		this.giveError(ruleOut8.error.code, "White space(optional)(" + ruleOut8.error.expected + ")", ruleOut8.error.found);
		
	}else{
		var string ruleOutCast8 = ruleOut8.data["data"];
charPos = this.offset;
		
		c = 9;
		
	}
}else if (c == 9) {
	var <string>CarpegNativeParserOutput ruleOut9 = this.String(input, charPos);
	
if (ruleOut9.hadError) {
		c = 10; charPos--; this.offset--;
		
	}else{
		var string ruleOutCast9 = ruleOut9.data["data"];
charPos = this.offset;
		data["label"] = ruleOutCast9;
		c = 10;
		this.error.vested++;
	}
}else if (c == 10) {
	var <string>CarpegNativeParserOutput ruleOut10 = this._(input, charPos);
	
if (ruleOut10.hadError) {
		this.giveError(ruleOut10.error.code, "White space(optional)(" + ruleOut10.error.expected + ")", ruleOut10.error.found);
		
	}else{
		var string ruleOutCast10 = ruleOut10.data["data"];
charPos = this.offset;
		
		c = 11;
		
	}
}else if (c == 11) {
	if (currentCode == 61) {
			
			c = 12;
			this.error.vested++;
	}else{
		this.giveError(1, "=", currentChar);
	}
}else if (c == 12) {
	var <string>CarpegNativeParserOutput ruleOut12 = this._(input, charPos);
	
if (ruleOut12.hadError) {
		this.giveError(ruleOut12.error.code, "White space(optional)(" + ruleOut12.error.expected + ")", ruleOut12.error.found);
		
	}else{
		var string ruleOutCast12 = ruleOut12.data["data"];
charPos = this.offset;
		
		c = 13;
		
	}
}else if (c == 13) {
	var <map>CarpegNativeParserOutput ruleOut13 = this.Expression(input, charPos);
	
if (ruleOut13.hadError) {
		this.giveError(ruleOut13.error.code, "Expression(" + ruleOut13.error.expected + ")", ruleOut13.error.found);
		
	}else{
		var map ruleOutCast13 = ruleOut13.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast13;
		c = 14;
		this.error.vested++;
	}
}else if (c == 14) {
	var <string>CarpegNativeParserOutput ruleOut14 = this._(input, charPos);
	
if (ruleOut14.hadError) {
		this.giveError(ruleOut14.error.code, "White space(optional)(" + ruleOut14.error.expected + ")", ruleOut14.error.found);
		
	}else{
		var string ruleOutCast14 = ruleOut14.data["data"];
charPos = this.offset;
		
		c = 15;
		
	}
}else if (c == 15) {
	if (currentCode == 59) {
			
			c = 16;
			this.error.vested++;
	}else{
		this.giveError(1, ";", currentChar);
	}
}else if (c == 16) {
	var <string>CarpegNativeParserOutput ruleOut16 = this._(input, charPos);
	
if (ruleOut16.hadError) {
		this.giveError(ruleOut16.error.code, "White space(optional)(" + ruleOut16.error.expected + ")", ruleOut16.error.found);
		
	}else{
		var string ruleOutCast16 = ruleOut16.data["data"];
charPos = this.offset;
		
		c = 17;
		
	}
}else if (c == 17) {
	var <map>CarpegNativeParserOutput ruleOut17 = this.Action_Block(input, charPos);
	
if (ruleOut17.hadError) {
		c = 18; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast17 = ruleOut17.data["data"];
charPos = this.offset;
		data["cap"] = ruleOutCast17;
		c = 18;
		this.error.vested++;
	}
}else if (c == 18) {
	var <string>CarpegNativeParserOutput ruleOut18 = this._(input, charPos);
	
if (ruleOut18.hadError) {
		this.giveError(ruleOut18.error.code, "White space(optional)(" + ruleOut18.error.expected + ")", ruleOut18.error.found);
		
	}else{
		var string ruleOutCast18 = ruleOut18.data["data"];
charPos = this.offset;
		if (true) {

var string castac18 = data[""];
var string actionCap18name = data["name"];var string actionCap18label = data["label"];var map actionCap18cap = data["cap"];var string actionCap18outputType = data["outputType"];var map actionCap18exp = data["exp"];dataStore["data"]["name"] = actionCap18name;
if (actionCap18label != empty) {
    dataStore["data"]["label"] = actionCap18label;
}
if (actionCap18cap != empty) {
    dataStore["data"]["cap"] = actionCap18cap;
}

dataStore["data"]["output"] = actionCap18outputType;
dataStore["data"]["expression"] = actionCap18exp;
}
		c = 0 - 1;
		
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Expression(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	
			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <map>CarpegNativeParserOutput ruleOut0 = this.Group_Expression(input, charPos);
	
if (ruleOut0.hadError) {
		c = 1; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast0;if (true) {

var map castacexp0 = data["exp"];
var map actionCap0exp = data["exp"];dataStore["data"] = actionCap0exp;}
		c = 0 - 1;
		this.error.vested++;
	}
}else if (c == 1) {
	var <map>CarpegNativeParserOutput ruleOut1 = this.Modify_Expression(input, charPos);
	
if (ruleOut1.hadError) {
		c = 2; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast1;if (true) {

var map castacexp0 = data["exp"];
var map actionCap0exp = data["exp"];dataStore["data"] = actionCap0exp;}
		c = 0 - 1;
		this.error.vested++;
	}
}else if (c == 2) {
	var <map>CarpegNativeParserOutput ruleOut2 = this.Group(input, charPos);
	
if (ruleOut2.hadError) {
		c = 3; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast2;if (true) {

var map castacexp0 = data["exp"];
var map actionCap0exp = data["exp"];dataStore["data"] = actionCap0exp;}
		c = 0 - 1;
		this.error.vested++;
	}
}else if (c == 3) {
	var <map>CarpegNativeParserOutput ruleOut3 = this.Simple_Expression(input, charPos);
	
if (ruleOut3.hadError) {
		this.giveError(1, "Group_Expression, Modify_Expression, Group, Simple_Expression", currentChar);
		
	}else{
		var map ruleOutCast3 = ruleOut3.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast3;if (true) {

var map castacexp0 = data["exp"];
var map actionCap0exp = data["exp"];dataStore["data"] = actionCap0exp;}
		c = 0 - 1;
		this.error.vested++;
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Sub_Expression(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	
			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <map>CarpegNativeParserOutput ruleOut0 = this.Modify_Expression(input, charPos);
	
if (ruleOut0.hadError) {
		c = 1; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast0;if (true) {

var map castacexp0 = data["exp"];
var map actionCap0exp = data["exp"];dataStore["data"] = actionCap0exp;}
		c = 0 - 1;
		this.error.vested++;
	}
}else if (c == 1) {
	var <map>CarpegNativeParserOutput ruleOut1 = this.Group(input, charPos);
	
if (ruleOut1.hadError) {
		c = 2; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast1;if (true) {

var map castacexp0 = data["exp"];
var map actionCap0exp = data["exp"];dataStore["data"] = actionCap0exp;}
		c = 0 - 1;
		this.error.vested++;
	}
}else if (c == 2) {
	var <map>CarpegNativeParserOutput ruleOut2 = this.Simple_Expression(input, charPos);
	
if (ruleOut2.hadError) {
		this.giveError(1, "Modify_Expression, Group, Simple_Expression", currentChar);
		
	}else{
		var map ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast2;if (true) {

var map castacexp0 = data["exp"];
var map actionCap0exp = data["exp"];dataStore["data"] = actionCap0exp;}
		c = 0 - 1;
		this.error.vested++;
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Group_Expression(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	

			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <string>CarpegNativeParserOutput ruleOut0 = this._(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "White space(optional)(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var string ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		
		c = 1;
		
	}
}else if (c == 1) {
	var <map>CarpegNativeParserOutput ruleOut1 = this.Action(input, charPos);
	
if (ruleOut1.hadError) {
		c = 2; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast1;if (true) {

var map castacexp1 = data["exp"];
var map actionCap1exp = data["exp"];dataStore["data"] = actionCap1exp;}
		c = 0 - 1;
		this.error.vested++;
	}
}else if (c == 2) {
	var <map>CarpegNativeParserOutput ruleOut2 = this.Sequence(input, charPos);
	
if (ruleOut2.hadError) {
		c = 3; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast2;if (true) {

var map castacexp1 = data["exp"];
var map actionCap1exp = data["exp"];dataStore["data"] = actionCap1exp;}
		c = 0 - 1;
		this.error.vested++;
	}
}else if (c == 3) {
	var <map>CarpegNativeParserOutput ruleOut3 = this.Choice(input, charPos);
	
if (ruleOut3.hadError) {
		this.giveError(1, "Action, Sequence, Choice", currentChar);
		
	}else{
		var map ruleOutCast3 = ruleOut3.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast3;if (true) {

var map castacexp1 = data["exp"];
var map actionCap1exp = data["exp"];dataStore["data"] = actionCap1exp;}
		c = 0 - 1;
		this.error.vested++;
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<string>CarpegNativeParserOutput>function Code(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new string();
dataStore["temp"] = new map();
	var string data = dataStore["temp"];
	var int c = 0;
	data["code"] = new string();

		var int brace = 0;	var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var string castnaccode0 = data["code"];
	
	
if (currentChar == "}") {
    if (brace == 0) {
        if (true) {

var string castaccode0 = data["code"];
var string actionCap0code = data["code"];dataStore["data"] = actionCap0code;}c = 0 - 1; charPos--; this.offset--;
    }else{
        data["code"] += currentChar;
if (true) {

var string castaccode0 = data["code"];
var string actionCap0code = data["code"];dataStore["data"] = actionCap0code;}
    }
    brace--;
}else{
    if (currentChar == "{") {
        brace++;
    }
    data["code"] += currentChar;
if (true) {

var string castaccode0 = data["code"];
var string actionCap0code = data["code"];dataStore["data"] = actionCap0code;}
}

}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <string>CarpegNativeParserOutput parseOutput = new <string>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Action_Block(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	






			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	if (currentCode == 123) {
			
			c = 1;
			this.error.vested++;
	}else{
		this.giveError(1, "{", currentChar);
	}
}else if (c == 1) {
	var <string>CarpegNativeParserOutput ruleOut1 = this._(input, charPos);
	
if (ruleOut1.hadError) {
		this.giveError(ruleOut1.error.code, "White space(optional)(" + ruleOut1.error.expected + ")", ruleOut1.error.found);
		
	}else{
		var string ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		
		c = 2;
		
	}
}else if (c == 2) {
	var <string>CarpegNativeParserOutput ruleOut2 = this.Type_Name(input, charPos);
	
if (ruleOut2.hadError) {
		this.giveError(ruleOut2.error.code, "Type_Name(" + ruleOut2.error.expected + ")", ruleOut2.error.found);
		
	}else{
		var string ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		data["type"] = ruleOutCast2;
		c = 3;
		
	}
}else if (c == 3) {
	var <string>CarpegNativeParserOutput ruleOut3 = this._(input, charPos);
	
if (ruleOut3.hadError) {
		this.giveError(ruleOut3.error.code, "White space(optional)(" + ruleOut3.error.expected + ")", ruleOut3.error.found);
		
	}else{
		var string ruleOutCast3 = ruleOut3.data["data"];
charPos = this.offset;
		
		c = 4;
		
	}
}else if (c == 4) {
	if (currentCode == 124) {
			
			c = 5;
			this.error.vested++;
	}else{
		this.giveError(1, "|", currentChar);
	}
}else if (c == 5) {
	var <string>CarpegNativeParserOutput ruleOut5 = this.Code(input, charPos);
	
if (ruleOut5.hadError) {
		this.giveError(ruleOut5.error.code, "Code(" + ruleOut5.error.expected + ")", ruleOut5.error.found);
		
	}else{
		var string ruleOutCast5 = ruleOut5.data["data"];
charPos = this.offset;
		data["code"] = ruleOutCast5;
		c = 6;
		
	}
}else if (c == 6) {
	if (currentCode == 125) {
			if (true) {

var string castac6 = data[""];
var string actionCap6type = data["type"];var string actionCap6code = data["code"];dataStore["data"]["type"] = actionCap6type;
dataStore["data"]["code"] = actionCap6code;
dataStore["data"]["typeType"] = "coded";
}
			c = 0 - 1;
			this.error.vested++;
	}else{
		this.giveError(1, "}", currentChar);
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<string>CarpegNativeParserOutput>function Action_String(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new string();
dataStore["temp"] = new map();
	var string data = dataStore["temp"];
	var int c = 0;
	
			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <string>CarpegNativeParserOutput ruleOut0 = this.String(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "String(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var string ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		data["str"] = ruleOutCast0;if (true) {

var string castacstr0 = data["str"];
var string actionCap0str = data["str"];dataStore["data"] = "\"" + actionCap0str + "\"";}
		c = 0 - 1;
		this.error.vested++;
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <string>CarpegNativeParserOutput parseOutput = new <string>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Action_Part(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	
data["name"] = new string();





			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <string>CarpegNativeParserOutput ruleOut0 = this._(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "White space(optional)(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var string ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		
		c = 1;
		
	}
}else if (c == 1) {
	var bool passed1 = false;
	
	if (passed1 == false) {
		if (int.mid(currentCode, 65, 90)) {passed1 = true;}else if (int.mid(currentCode, 97, 122)) {passed1 = true;}else if (int.mid(currentCode, 48, 57)) {passed1 = true;}
	}
	if (passed1) {
		data["name"] += currentChar;
if (charPos == input.length() - 1) {this.giveError(2, "EOF", currentChar);}

c = 1;		this.error.vested++;

	}else{
		c = 2; charPos--; this.offset--;
	}
}else if (c == 2) {
	var <string>CarpegNativeParserOutput ruleOut2 = this._(input, charPos);
	
if (ruleOut2.hadError) {
		this.giveError(ruleOut2.error.code, "White space(optional)(" + ruleOut2.error.expected + ")", ruleOut2.error.found);
		
	}else{
		var string ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		
		c = 3;
		
	}
}else if (c == 3) {
	if (currentCode == 58) {
			
			c = 4;
			this.error.vested++;
	}else{
		this.giveError(1, ":", currentChar);
	}
}else if (c == 4) {
	var <string>CarpegNativeParserOutput ruleOut4 = this._(input, charPos);
	
if (ruleOut4.hadError) {
		this.giveError(ruleOut4.error.code, "White space(optional)(" + ruleOut4.error.expected + ")", ruleOut4.error.found);
		
	}else{
		var string ruleOutCast4 = ruleOut4.data["data"];
charPos = this.offset;
		
		c = 5;
		
	}
}else if (c == 5) {
	var <string>CarpegNativeParserOutput ruleOut5 = this.Action_String(input, charPos);
	
if (ruleOut5.hadError) {
		c = 6; charPos--; this.offset--;
		
	}else{
		var string ruleOutCast5 = ruleOut5.data["data"];
charPos = this.offset;
		data["value"] = ruleOutCast5;if (true) {

var map castacvalue5 = data["value"];
var string actionCap5name = data["name"];var map actionCap5value = data["value"];dataStore["data"]["name"] = actionCap5name;
dataStore["data"]["value"] = actionCap5value;
}
		c = 0 - 1;
		this.error.vested++;
	}
}else if (c == 6) {
	var <string>CarpegNativeParserOutput ruleOut6 = this.Code_Block(input, charPos);
	
if (ruleOut6.hadError) {
		c = 7; charPos--; this.offset--;
		
	}else{
		var string ruleOutCast6 = ruleOut6.data["data"];
charPos = this.offset;
		data["value"] = ruleOutCast6;if (true) {

var map castacvalue5 = data["value"];
var string actionCap5name = data["name"];var map actionCap5value = data["value"];dataStore["data"]["name"] = actionCap5name;
dataStore["data"]["value"] = actionCap5value;
}
		c = 0 - 1;
		this.error.vested++;
	}
}else if (c == 7) {
	var <map>CarpegNativeParserOutput ruleOut7 = this.Action_Map(input, charPos);
	
if (ruleOut7.hadError) {
		this.giveError(1, "Action_String, Code_Block, Action_Map", currentChar);
		
	}else{
		var map ruleOutCast7 = ruleOut7.data["data"];
charPos = this.offset;
		data["value"] = ruleOutCast7;if (true) {

var map castacvalue5 = data["value"];
var string actionCap5name = data["name"];var map actionCap5value = data["value"];dataStore["data"]["name"] = actionCap5name;
dataStore["data"]["value"] = actionCap5value;
}
		c = 0 - 1;
		this.error.vested++;
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Action_Map(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	

data["acts"] = new <map>array();



			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	if (currentCode == 123) {
			
			c = 1;
			this.error.vested++;
	}else{
		this.giveError(1, "{", currentChar);
	}
}else if (c == 1) {
	var <string>CarpegNativeParserOutput ruleOut1 = this._(input, charPos);
	
if (ruleOut1.hadError) {
		this.giveError(ruleOut1.error.code, "White space(optional)(" + ruleOut1.error.expected + ")", ruleOut1.error.found);
		
	}else{
		var string ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		
		c = 2;
		
	}
}else if (c == 2) {
	var <map>CarpegNativeParserOutput ruleOut2 = this.Action_Part(input, charPos);
	
if (ruleOut2.hadError) {
		c = 3; charPos--; this.offset--;
		if (ruleOut2.error.vested > 1) {this.giveError(ruleOut2.error.code, ruleOut2.error.expected, ruleOut2.error.found);}
	}else{
		var map ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		var <map>array castacts2 = data["acts"];
castacts2.push(ruleOutCast2);
if (input.charCodeAt(charPos + 1) != 44) {
c = 3;continue;}else {charPos++;}if (charPos == input.length() - 1) {this.giveError(2, "EOF", currentChar);}

		c = 2;
		this.error.vested++;
	}
}else if (c == 3) {
	var <string>CarpegNativeParserOutput ruleOut3 = this._(input, charPos);
	
if (ruleOut3.hadError) {
		this.giveError(ruleOut3.error.code, "White space(optional)(" + ruleOut3.error.expected + ")", ruleOut3.error.found);
		
	}else{
		var string ruleOutCast3 = ruleOut3.data["data"];
charPos = this.offset;
		
		c = 4;
		
	}
}else if (c == 4) {
	if (currentCode == 125) {
			if (true) {

var string castac4 = data[""];
var <map>array actionCap4acts = data["acts"];
dataStore["data"]["type"] = "map";
dataStore["data"]["code"] = new map();
for (var int i in actionCap4acts) {
    var map act = actionCap4acts[i];
    dataStore["data"]["code"][act["name"]] = act["value"];
}
dataStore["data"]["typeType"] = "maped";
}
			c = 0 - 1;
			this.error.vested++;
	}else{
		this.giveError(1, "}", currentChar);
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<string>CarpegNativeParserOutput>function Code_Block(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new string();
dataStore["temp"] = new map();
	var string data = dataStore["temp"];
	var int c = 0;
	


			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	if (currentCode == 123) {
			
			c = 1;
			this.error.vested++;
	}else{
		this.giveError(1, "{", currentChar);
	}
}else if (c == 1) {
	var <string>CarpegNativeParserOutput ruleOut1 = this.Code(input, charPos);
	
if (ruleOut1.hadError) {
		this.giveError(ruleOut1.error.code, "Code(" + ruleOut1.error.expected + ")", ruleOut1.error.found);
		
	}else{
		var string ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		data["code"] = ruleOutCast1;
		c = 2;
		
	}
}else if (c == 2) {
	if (currentCode == 125) {
			if (true) {

var string castac2 = data[""];
var string actionCap2code = data["code"];dataStore["data"] = actionCap2code;}
			c = 0 - 1;
			this.error.vested++;
	}else{
		this.giveError(1, "}", currentChar);
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <string>CarpegNativeParserOutput parseOutput = new <string>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Action(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	



			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <string>CarpegNativeParserOutput ruleOut0 = this._(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "White space(optional)(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var string ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		
		c = 1;
		
	}
}else if (c == 1) {
	var <map>CarpegNativeParserOutput ruleOut1 = this.Sequence(input, charPos);
	
if (ruleOut1.hadError) {
		c = 2; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast1;
		c = 4;
		this.error.vested++;
	}
}else if (c == 2) {
	var <map>CarpegNativeParserOutput ruleOut2 = this.Choice(input, charPos);
	
if (ruleOut2.hadError) {
		c = 3; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast2;
		c = 4;
		this.error.vested++;
	}
}else if (c == 3) {
	var <map>CarpegNativeParserOutput ruleOut3 = this.Sub_Expression(input, charPos);
	
if (ruleOut3.hadError) {
		this.giveError(1, "Sequence, Choice, Sub_Expression", currentChar);
		
	}else{
		var map ruleOutCast3 = ruleOut3.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast3;
		c = 4;
		this.error.vested++;
	}
}else if (c == 4) {
	var <string>CarpegNativeParserOutput ruleOut4 = this._(input, charPos);
	
if (ruleOut4.hadError) {
		this.giveError(ruleOut4.error.code, "White space(optional)(" + ruleOut4.error.expected + ")", ruleOut4.error.found);
		
	}else{
		var string ruleOutCast4 = ruleOut4.data["data"];
charPos = this.offset;
		
		c = 5;
		
	}
}else if (c == 5) {
	var <map>CarpegNativeParserOutput ruleOut5 = this.Action_Block(input, charPos);
	
if (ruleOut5.hadError) {
		c = 6; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast5 = ruleOut5.data["data"];
charPos = this.offset;
		data["act"] = ruleOutCast5;if (true) {

var map castacact5 = data["act"];
var map actionCap5act = data["act"];var map actionCap5exp = data["exp"];dataStore["data"]["type"] = "action";
dataStore["data"]["code"] = actionCap5act["code"];
dataStore["data"]["outputType"] = actionCap5act["type"];
dataStore["data"]["typeType"] = "coded";
dataStore["data"]["expression"] = actionCap5exp;
dataStore["data"]["location"] = false;
}
		c = 0 - 1;
		this.error.vested++;
	}
}else if (c == 6) {
	var <map>CarpegNativeParserOutput ruleOut6 = this.Action_Map(input, charPos);
	
if (ruleOut6.hadError) {
		this.giveError(1, "Action_Block, Action_Map", currentChar);
		
	}else{
		var map ruleOutCast6 = ruleOut6.data["data"];
charPos = this.offset;
		data["act"] = ruleOutCast6;if (true) {

var map castacact5 = data["act"];
var map actionCap5act = data["act"];var map actionCap5exp = data["exp"];dataStore["data"]["type"] = "action";
dataStore["data"]["code"] = actionCap5act["code"];
dataStore["data"]["outputType"] = actionCap5act["type"];
dataStore["data"]["typeType"] = "coded";
dataStore["data"]["expression"] = actionCap5exp;
dataStore["data"]["location"] = false;
}
		c = 0 - 1;
		this.error.vested++;
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Group(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	





			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <string>CarpegNativeParserOutput ruleOut0 = this._(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "White space(optional)(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var string ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		
		c = 1;
		
	}
}else if (c == 1) {
	if (currentCode == 40) {
			
			c = 2;
			this.error.vested++;
	}else{
		this.giveError(1, "(", currentChar);
	}
}else if (c == 2) {
	var <map>CarpegNativeParserOutput ruleOut2 = this.Expression(input, charPos);
	
if (ruleOut2.hadError) {
		this.giveError(ruleOut2.error.code, "Expression(" + ruleOut2.error.expected + ")", ruleOut2.error.found);
		
	}else{
		var map ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast2;
		c = 3;
		this.error.vested++;
	}
}else if (c == 3) {
	var <string>CarpegNativeParserOutput ruleOut3 = this._(input, charPos);
	
if (ruleOut3.hadError) {
		this.giveError(ruleOut3.error.code, "White space(optional)(" + ruleOut3.error.expected + ")", ruleOut3.error.found);
		
	}else{
		var string ruleOutCast3 = ruleOut3.data["data"];
charPos = this.offset;
		
		c = 4;
		
	}
}else if (c == 4) {
	if (currentCode == 41) {
			
			c = 5;
			this.error.vested++;
	}else{
		this.giveError(1, ")", currentChar);
	}
}else if (c == 5) {
	var <string>CarpegNativeParserOutput ruleOut5 = this._(input, charPos);
	
if (ruleOut5.hadError) {
		this.giveError(ruleOut5.error.code, "White space(optional)(" + ruleOut5.error.expected + ")", ruleOut5.error.found);
		
	}else{
		var string ruleOutCast5 = ruleOut5.data["data"];
charPos = this.offset;
		if (true) {

var string castac5 = data[""];
var map actionCap5exp = data["exp"];
var bool doAround = false;
if (actionCap5exp["type"] == "labeled") {
    doAround = true;
}else if (actionCap5exp["type"] == "sequence") {
    doAround = true;
}
if (doAround) {
    dataStore["data"]["type"] = "group";
    dataStore["data"]["expression"] = actionCap5exp;
    dataStore["data"]["location"] = false;
}else{
    dataStore["data"] = actionCap5exp;
}
}
		c = 0 - 1;
		
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Sequence(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	data["cont"] = new map();
var map captureRoot1 = data["cont"];

captureRoot1["exps"] = new <map>array();

			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <map>CarpegNativeParserOutput ruleOut0 = this.Sub_Expression(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "Sub_Expression(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var map ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		captureRoot1["exp"] = ruleOutCast0;
		c = 1;
		this.error.vested++;
	}
}else if (c == 1) {
	var <map>CarpegNativeParserOutput ruleOut1 = this.Sub_Expression(input, charPos);
	
if (ruleOut1.hadError) {
		var <map>array castexps1 = captureRoot1["exps"];
if (castexps1.length() >= 1) {
c = 0 - 1; charPos--; this.offset--;}else{
this.giveError(1, "Sub_Expression", currentChar);}

		
	}else{
		var map ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		var <map>array castexps1 = captureRoot1["exps"];
castexps1.push(ruleOutCast1);

		c = 1;
		this.error.vested++;
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {var map actionCapendcont = data["cont"];dataStore["data"]["type"] = "sequence";
dataStore["data"]["location"] = false;
var <map>array exps = actionCapendcont["exps"];
exps.unshift(actionCapendcont["exp"]);
dataStore["data"]["elements"] = exps;this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Choice(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	data["exps"] = new <map>array();


			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <map>CarpegNativeParserOutput ruleOut0 = this.Sub_Expression(input, charPos);
	
if (ruleOut0.hadError) {
		var <map>array castexps0 = data["exps"];
if (castexps0.length() >= 1) {
c = 1; charPos--; this.offset--;}else{
this.giveError(1, "Sub_Expression", currentChar);}

		
	}else{
		var map ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		var <map>array castexps0 = data["exps"];
castexps0.push(ruleOutCast0);
if (input.charCodeAt(charPos + 1) != 47) {
c = 1;continue;}else {charPos++;}
		c = 0;
		this.error.vested++;
	}
}else if (c == 1) {
	var <string>CarpegNativeParserOutput ruleOut1 = this._(input, charPos);
	
if (ruleOut1.hadError) {
		this.giveError(ruleOut1.error.code, "White space(optional)(" + ruleOut1.error.expected + ")", ruleOut1.error.found);
		
	}else{
		var string ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		
		c = 0 - 1;
		
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {var <map>array actionCapendexps = data["exps"];dataStore["data"]["type"] = "choice";
dataStore["data"]["location"] = false;
if (actionCapendexps.length() < 2) {this.giveError(1, "" + "" + "", "");}
dataStore["data"]["alternatives"] = actionCapendexps;this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Simple_Expression(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	


			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <string>CarpegNativeParserOutput ruleOut0 = this._(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "White space(optional)(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var string ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		
		c = 1;
		
	}
}else if (c == 1) {
	var <map>CarpegNativeParserOutput ruleOut1 = this.Any(input, charPos);
	
if (ruleOut1.hadError) {
		c = 2; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast1;
		c = 7;
		this.error.vested++;
	}
}else if (c == 2) {
	var <map>CarpegNativeParserOutput ruleOut2 = this.Rule_Reference(input, charPos);
	
if (ruleOut2.hadError) {
		c = 3; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast2;
		c = 7;
		
	}
}else if (c == 3) {
	var <map>CarpegNativeParserOutput ruleOut3 = this.String_Literal(input, charPos);
	
if (ruleOut3.hadError) {
		c = 4; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast3 = ruleOut3.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast3;
		c = 7;
		this.error.vested++;
	}
}else if (c == 4) {
	var <map>CarpegNativeParserOutput ruleOut4 = this.Class(input, charPos);
	
if (ruleOut4.hadError) {
		c = 5; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast4 = ruleOut4.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast4;
		c = 7;
		this.error.vested++;
	}
}else if (c == 5) {
	var <map>CarpegNativeParserOutput ruleOut5 = this.Native(input, charPos);
	
if (ruleOut5.hadError) {
		c = 6; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast5 = ruleOut5.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast5;
		c = 7;
		this.error.vested++;
	}
}else if (c == 6) {
	var <map>CarpegNativeParserOutput ruleOut6 = this.Group(input, charPos);
	
if (ruleOut6.hadError) {
		this.giveError(1, "Any, Rule_Reference, String_Literal, Class, Native, Group", currentChar);
		
	}else{
		var map ruleOutCast6 = ruleOut6.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast6;
		c = 7;
		this.error.vested++;
	}
}else if (c == 7) {
	var <string>CarpegNativeParserOutput ruleOut7 = this._(input, charPos);
	
if (ruleOut7.hadError) {
		this.giveError(ruleOut7.error.code, "White space(optional)(" + ruleOut7.error.expected + ")", ruleOut7.error.found);
		
	}else{
		var string ruleOutCast7 = ruleOut7.data["data"];
charPos = this.offset;
		if (true) {

var string castac7 = data[""];
var map actionCap7exp = data["exp"];dataStore["data"] = actionCap7exp;}
		c = 0 - 1;
		
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function String_Literal(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	
			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <string>CarpegNativeParserOutput ruleOut0 = this.String(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "String(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var string ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		data["string"] = ruleOutCast0;if (true) {

var string castacstring0 = data["string"];
var string actionCap0string = data["string"];dataStore["data"]["type"] = "literal";
dataStore["data"]["value"] = actionCap0string;
dataStore["data"]["ignoreCase"] = false;
dataStore["data"]["location"] = false;
}
		c = 0 - 1;
		this.error.vested++;
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Rule_Reference(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	
			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <string>CarpegNativeParserOutput ruleOut0 = this.Safe_Name(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "Safe_Name(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var string ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		data["rule"] = ruleOutCast0;if (true) {

var string castacrule0 = data["rule"];
var string actionCap0rule = data["rule"];dataStore["data"]["type"] = "rule_ref";
dataStore["data"]["name"] = actionCap0rule;
dataStore["data"]["location"] = false;
}
		c = 0 - 1;
		
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Class_Range(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	


			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	if (currentChar == "\u0001") {
		this.giveError(1, "Anything", currentChar);
	}else{
		data["first"] = currentChar;
		c = 1;
		this.error.vested++;
	}}else if (c == 1) {
	if (currentCode == 45) {
			
			c = 2;
			this.error.vested++;
	}else{
		this.giveError(1, "-", currentChar);
	}
}else if (c == 2) {
	if (currentChar == "\u0001") {
		this.giveError(1, "Anything", currentChar);
	}else{
		data["last"] = currentChar;if (true) {

var string castaclast2 = data["last"];
var string actionCap2first = data["first"];var string actionCap2last = data["last"];dataStore["data"] = [actionCap2first, actionCap2last];}
		c = 0 - 1;
		this.error.vested++;
	}}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Class(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	

data["r"] = new <map>array();


		
var bool escaped = false;
var map escapeCodes = new map();
escapeCodes["n"] = "\n";
escapeCodes["b"] = "\b";
escapeCodes["f"] = "\f";
escapeCodes["r"] = "\r";
escapeCodes["t"] = "\t";
escapeCodes["v"] = "\v";
escapeCodes["\\"] = "\\";
	var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	if (currentCode == 91) {
			
			c = 1;
			this.error.vested++;
	}else{
		this.giveError(1, "[", currentChar);
	}
}else if (c == 1) {
	if (currentCode == 94) {
			data["neg"] = "^";
			c = 2;
			this.error.vested++;
	}else{
		c = 2; charPos--; this.offset--;
	}
}else if (c == 2) {
	var <map>CarpegNativeParserOutput ruleOut2 = this.Class_Range(input, charPos);
	
if (ruleOut2.hadError) {
		c = 3; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		var <map>array castr2 = data["r"];
castr2.push(ruleOutCast2);
if (charPos == input.length() - 1) {this.giveError(2, "EOF", currentChar);}

		c = 2;
		this.error.vested++;
	}
}else if (c == 3) {
	var string castnacr3 = data["r"];
	
	

var bool doCapture = true;

if (currentChar == "\\") {if (escaped == false) {escaped = true; doCapture = false;}}

if (escaped and doCapture) {
  doCapture = false;
  var <string>array castr2 = data["r"];
castr2.push(escapeCodes[currentChar]);
if (charPos == input.length() - 1) {this.giveError(2, "EOF", currentChar);}

  escaped = false;
}

if (escaped == false) {
if (currentChar == "]") {
    c = 4; charPos--; this.offset--;
    doCapture = false;
}
}

if (doCapture) {
  var <string>array castr2 = data["r"];
castr2.push(currentChar);
if (charPos == input.length() - 1) {this.giveError(2, "EOF", currentChar);}

}


}else if (c == 4) {
	if (currentCode == 93) {
			if (true) {

var string castac4 = data[""];
var <map>array actionCap4r = data["r"];var string actionCap4neg = data["neg"];
dataStore["data"]["type"] = "class";
dataStore["data"]["parts"] = actionCap4r;
dataStore["data"]["inverted"] = false;
if (actionCap4neg != empty) {
    dataStore["data"]["inverted"] = true;
}
dataStore["data"]["location"] = false;}
			c = 0 - 1;
			this.error.vested++;
	}else{
		this.giveError(1, "]", currentChar);
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Any(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	
			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	if (currentCode == 46) {
			if (true) {

var string castac0 = data[""];
dataStore["data"]["type"] = "any";
dataStore["data"]["location"] = false;
}
			c = 0 - 1;
			this.error.vested++;
	}else{
		this.giveError(1, ".", currentChar);
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Native(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	






data["code"] = new string();


		var string endChar = ">";	var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	if (currentCode == 60) {
			
			c = 1;
			this.error.vested++;
	}else{
		this.giveError(1, "<", currentChar);
	}
}else if (c == 1) {
	var <string>CarpegNativeParserOutput ruleOut1 = this._(input, charPos);
	
if (ruleOut1.hadError) {
		this.giveError(ruleOut1.error.code, "White space(optional)(" + ruleOut1.error.expected + ")", ruleOut1.error.found);
		
	}else{
		var string ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		
		c = 2;
		
	}
}else if (c == 2) {
	var <string>CarpegNativeParserOutput ruleOut2 = this.Type_Name(input, charPos);
	
if (ruleOut2.hadError) {
		this.giveError(ruleOut2.error.code, "Type_Name(" + ruleOut2.error.expected + ")", ruleOut2.error.found);
		
	}else{
		var string ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		data["type"] = ruleOutCast2;
		c = 3;
		
	}
}else if (c == 3) {
	var <string>CarpegNativeParserOutput ruleOut3 = this._(input, charPos);
	
if (ruleOut3.hadError) {
		this.giveError(ruleOut3.error.code, "White space(optional)(" + ruleOut3.error.expected + ")", ruleOut3.error.found);
		
	}else{
		var string ruleOutCast3 = ruleOut3.data["data"];
charPos = this.offset;
		
		c = 4;
		
	}
}else if (c == 4) {
	var <string>CarpegNativeParserOutput ruleOut4 = this.Code_Block(input, charPos);
	
if (ruleOut4.hadError) {
		c = 5; charPos--; this.offset--;
		
	}else{
		var string ruleOutCast4 = ruleOut4.data["data"];
charPos = this.offset;
		data["act"] = ruleOutCast4;
		c = 6;
		this.error.vested++;
	}
}else if (c == 5) {
	var <string>CarpegNativeParserOutput ruleOut5 = this._(input, charPos);
	
if (ruleOut5.hadError) {
		this.giveError(1, "Code_Block, White space(optional)", currentChar);
		
	}else{
		var string ruleOutCast5 = ruleOut5.data["data"];
charPos = this.offset;
		data["act"] = ruleOutCast5;
		c = 6;
		
	}
}else if (c == 6) {
	var <string>CarpegNativeParserOutput ruleOut6 = this._(input, charPos);
	
if (ruleOut6.hadError) {
		this.giveError(ruleOut6.error.code, "White space(optional)(" + ruleOut6.error.expected + ")", ruleOut6.error.found);
		
	}else{
		var string ruleOutCast6 = ruleOut6.data["data"];
charPos = this.offset;
		
		c = 7;
		
	}
}else if (c == 7) {
	if (currentCode == 124) {
			
			c = 8;
			this.error.vested++;
	}else{
		this.giveError(1, "|", currentChar);
	}
}else if (c == 8) {
	var string castnaccode8 = data["code"];
	
	if (currentChar == endChar) {c = 9; charPos--; this.offset--;}else{data["code"] += currentChar;
}
}else if (c == 9) {
	if (currentCode == 62) {
			if (true) {

var string castac9 = data[""];
var string actionCap9type = data["type"];var map actionCap9act = data["act"];var string actionCap9code = data["code"];dataStore["data"]["type"] = "native";
dataStore["data"]["outputType"] = actionCap9type;
dataStore["data"]["initializer"] = actionCap9act;
dataStore["data"]["code"] = actionCap9code;
}
			c = 0 - 1;
			this.error.vested++;
	}else{
		this.giveError(1, ">", currentChar);
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Modify_Expression(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	


			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <string>CarpegNativeParserOutput ruleOut0 = this._(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "White space(optional)(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var string ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		
		c = 1;
		
	}
}else if (c == 1) {
	var <map>CarpegNativeParserOutput ruleOut1 = this.Labeled(input, charPos);
	
if (ruleOut1.hadError) {
		c = 2; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast1;
		c = 6;
		this.error.vested++;
	}
}else if (c == 2) {
	var <map>CarpegNativeParserOutput ruleOut2 = this.Optional(input, charPos);
	
if (ruleOut2.hadError) {
		c = 3; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast2;
		c = 6;
		this.error.vested++;
	}
}else if (c == 3) {
	var <map>CarpegNativeParserOutput ruleOut3 = this.Not(input, charPos);
	
if (ruleOut3.hadError) {
		c = 4; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast3 = ruleOut3.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast3;
		c = 6;
		this.error.vested++;
	}
}else if (c == 4) {
	var <map>CarpegNativeParserOutput ruleOut4 = this.List_Pipe(input, charPos);
	
if (ruleOut4.hadError) {
		c = 5; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast4 = ruleOut4.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast4;
		c = 6;
		this.error.vested++;
	}
}else if (c == 5) {
	var <map>CarpegNativeParserOutput ruleOut5 = this.List(input, charPos);
	
if (ruleOut5.hadError) {
		this.giveError(1, "Labeled, Optional, Not, List_Pipe, List", currentChar);
		
	}else{
		var map ruleOutCast5 = ruleOut5.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast5;
		c = 6;
		this.error.vested++;
	}
}else if (c == 6) {
	var <string>CarpegNativeParserOutput ruleOut6 = this._(input, charPos);
	
if (ruleOut6.hadError) {
		this.giveError(ruleOut6.error.code, "White space(optional)(" + ruleOut6.error.expected + ")", ruleOut6.error.found);
		
	}else{
		var string ruleOutCast6 = ruleOut6.data["data"];
charPos = this.offset;
		if (true) {

var string castac6 = data[""];
var map actionCap6exp = data["exp"];dataStore["data"] = actionCap6exp;}
		c = 0 - 1;
		
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Labeled(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	





			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <string>CarpegNativeParserOutput ruleOut0 = this._(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "White space(optional)(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var string ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		
		c = 1;
		
	}
}else if (c == 1) {
	var <string>CarpegNativeParserOutput ruleOut1 = this.Safe_Name(input, charPos);
	
if (ruleOut1.hadError) {
		this.giveError(ruleOut1.error.code, "Safe_Name(" + ruleOut1.error.expected + ")", ruleOut1.error.found);
		
	}else{
		var string ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		data["label"] = ruleOutCast1;
		c = 2;
		
	}
}else if (c == 2) {
	var <string>CarpegNativeParserOutput ruleOut2 = this._(input, charPos);
	
if (ruleOut2.hadError) {
		this.giveError(ruleOut2.error.code, "White space(optional)(" + ruleOut2.error.expected + ")", ruleOut2.error.found);
		
	}else{
		var string ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		
		c = 3;
		
	}
}else if (c == 3) {
	if (currentCode == 58) {
			
			c = 4;
			this.error.vested++;
	}else{
		this.giveError(1, ":", currentChar);
	}
}else if (c == 4) {
	var <map>CarpegNativeParserOutput ruleOut4 = this.Sub_Expression(input, charPos);
	
if (ruleOut4.hadError) {
		this.giveError(ruleOut4.error.code, "Sub_Expression(" + ruleOut4.error.expected + ")", ruleOut4.error.found);
		
	}else{
		var map ruleOutCast4 = ruleOut4.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast4;
		c = 5;
		this.error.vested++;
	}
}else if (c == 5) {
	var <string>CarpegNativeParserOutput ruleOut5 = this._(input, charPos);
	
if (ruleOut5.hadError) {
		this.giveError(ruleOut5.error.code, "White space(optional)(" + ruleOut5.error.expected + ")", ruleOut5.error.found);
		
	}else{
		var string ruleOutCast5 = ruleOut5.data["data"];
charPos = this.offset;
		if (true) {

var string castac5 = data[""];
var string actionCap5label = data["label"];var map actionCap5exp = data["exp"];dataStore["data"]["type"] = "labeled";
dataStore["data"]["label"] = actionCap5label;
dataStore["data"]["expression"] = actionCap5exp;
dataStore["data"]["location"] = false;
}
		c = 0 - 1;
		
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function List_Pipe(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	




			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <map>CarpegNativeParserOutput ruleOut0 = this.List_One_Raw(input, charPos);
	
if (ruleOut0.hadError) {
		c = 1; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		data["l"] = ruleOutCast0;
		c = 4;
		this.error.vested++;
	}
}else if (c == 1) {
	var <map>CarpegNativeParserOutput ruleOut1 = this.List_One(input, charPos);
	
if (ruleOut1.hadError) {
		c = 2; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		data["l"] = ruleOutCast1;
		c = 4;
		this.error.vested++;
	}
}else if (c == 2) {
	var <map>CarpegNativeParserOutput ruleOut2 = this.List_Zero_Raw(input, charPos);
	
if (ruleOut2.hadError) {
		c = 3; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		data["l"] = ruleOutCast2;
		c = 4;
		this.error.vested++;
	}
}else if (c == 3) {
	var <map>CarpegNativeParserOutput ruleOut3 = this.List_Zero(input, charPos);
	
if (ruleOut3.hadError) {
		this.giveError(1, "List_One_Raw, List_One, List_Zero_Raw, List_Zero", currentChar);
		
	}else{
		var map ruleOutCast3 = ruleOut3.data["data"];
charPos = this.offset;
		data["l"] = ruleOutCast3;
		c = 4;
		this.error.vested++;
	}
}else if (c == 4) {
	var <string>CarpegNativeParserOutput ruleOut4 = this._(input, charPos);
	
if (ruleOut4.hadError) {
		this.giveError(ruleOut4.error.code, "White space(optional)(" + ruleOut4.error.expected + ")", ruleOut4.error.found);
		
	}else{
		var string ruleOutCast4 = ruleOut4.data["data"];
charPos = this.offset;
		
		c = 5;
		
	}
}else if (c == 5) {
	if (currentCode == 124) {
			
			c = 6;
			this.error.vested++;
	}else{
		this.giveError(1, "|", currentChar);
	}
}else if (c == 6) {
	var <string>CarpegNativeParserOutput ruleOut6 = this._(input, charPos);
	
if (ruleOut6.hadError) {
		this.giveError(ruleOut6.error.code, "White space(optional)(" + ruleOut6.error.expected + ")", ruleOut6.error.found);
		
	}else{
		var string ruleOutCast6 = ruleOut6.data["data"];
charPos = this.offset;
		
		c = 7;
		
	}
}else if (c == 7) {
	var <map>CarpegNativeParserOutput ruleOut7 = this.String_Literal(input, charPos);
	
if (ruleOut7.hadError) {
		c = 8; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast7 = ruleOut7.data["data"];
charPos = this.offset;
		data["pipe"] = ruleOutCast7;if (true) {

var map castacpipe7 = data["pipe"];
var map actionCap7l = data["l"];var map actionCap7pipe = data["pipe"];dataStore["data"] = actionCap7l; dataStore["data"]["pipe"] = actionCap7pipe;}
		c = 0 - 1;
		this.error.vested++;
	}
}else if (c == 8) {
	var <map>CarpegNativeParserOutput ruleOut8 = this.Rule_Reference(input, charPos);
	
if (ruleOut8.hadError) {
		this.giveError(1, "String_Literal, Rule_Reference", currentChar);
		
	}else{
		var map ruleOutCast8 = ruleOut8.data["data"];
charPos = this.offset;
		data["pipe"] = ruleOutCast8;if (true) {

var map castacpipe7 = data["pipe"];
var map actionCap7l = data["l"];var map actionCap7pipe = data["pipe"];dataStore["data"] = actionCap7l; dataStore["data"]["pipe"] = actionCap7pipe;}
		c = 0 - 1;
		
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function List(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	
			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <map>CarpegNativeParserOutput ruleOut0 = this.List_One_Raw(input, charPos);
	
if (ruleOut0.hadError) {
		c = 1; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		data["l"] = ruleOutCast0;if (true) {

var map castacl0 = data["l"];
var map actionCap0l = data["l"];dataStore["data"] = actionCap0l;}
		c = 0 - 1;
		this.error.vested++;
	}
}else if (c == 1) {
	var <map>CarpegNativeParserOutput ruleOut1 = this.List_One(input, charPos);
	
if (ruleOut1.hadError) {
		c = 2; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		data["l"] = ruleOutCast1;if (true) {

var map castacl0 = data["l"];
var map actionCap0l = data["l"];dataStore["data"] = actionCap0l;}
		c = 0 - 1;
		this.error.vested++;
	}
}else if (c == 2) {
	var <map>CarpegNativeParserOutput ruleOut2 = this.List_Zero_Raw(input, charPos);
	
if (ruleOut2.hadError) {
		c = 3; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		data["l"] = ruleOutCast2;if (true) {

var map castacl0 = data["l"];
var map actionCap0l = data["l"];dataStore["data"] = actionCap0l;}
		c = 0 - 1;
		this.error.vested++;
	}
}else if (c == 3) {
	var <map>CarpegNativeParserOutput ruleOut3 = this.List_Zero(input, charPos);
	
if (ruleOut3.hadError) {
		this.giveError(1, "List_One_Raw, List_One, List_Zero_Raw, List_Zero", currentChar);
		
	}else{
		var map ruleOutCast3 = ruleOut3.data["data"];
charPos = this.offset;
		data["l"] = ruleOutCast3;if (true) {

var map castacl0 = data["l"];
var map actionCap0l = data["l"];dataStore["data"] = actionCap0l;}
		c = 0 - 1;
		this.error.vested++;
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function List_Zero(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	

			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <map>CarpegNativeParserOutput ruleOut0 = this.Simple_Expression(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "Simple_Expression(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var map ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast0;
		c = 1;
		this.error.vested++;
	}
}else if (c == 1) {
	if (currentCode == 42) {
			if (true) {

var string castac1 = data[""];
var map actionCap1exp = data["exp"];dataStore["data"]["type"] = "zero_or_more";
dataStore["data"]["expression"] = actionCap1exp;
dataStore["data"]["location"] = false;
}
			c = 0 - 1;
			this.error.vested++;
	}else{
		this.giveError(1, "*", currentChar);
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function List_Zero_Raw(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	

			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <map>CarpegNativeParserOutput ruleOut0 = this.Simple_Expression(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "Simple_Expression(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var map ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast0;
		c = 1;
		this.error.vested++;
	}
}else if (c == 1) {
	var <int>array lit1 = [42, 42];
	if (currentCode == lit1[literalChar]) {
		literalChar++;
		if (literalChar == 2) {
			if (true) {

var string castac1 = data[""];
var map actionCap1exp = data["exp"];dataStore["data"]["type"] = "zero_or_more_raw";
dataStore["data"]["expression"] = actionCap1exp;
dataStore["data"]["location"] = false;
}
			c = 0 - 1;
			literalChar = 0;
}
			this.error.vested++;
	}else{
		this.giveError(1, "" + this.assembleCodes(lit1) + "", currentChar);
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function List_One(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	

			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <map>CarpegNativeParserOutput ruleOut0 = this.Simple_Expression(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "Simple_Expression(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var map ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast0;
		c = 1;
		this.error.vested++;
	}
}else if (c == 1) {
	if (currentCode == 43) {
			if (true) {

var string castac1 = data[""];
var map actionCap1exp = data["exp"];dataStore["data"]["type"] = "one_or_more";
dataStore["data"]["expression"] = actionCap1exp;
dataStore["data"]["location"] = false;
}
			c = 0 - 1;
			this.error.vested++;
	}else{
		this.giveError(1, "+", currentChar);
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function List_One_Raw(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	

			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <map>CarpegNativeParserOutput ruleOut0 = this.Simple_Expression(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "Simple_Expression(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var map ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast0;
		c = 1;
		this.error.vested++;
	}
}else if (c == 1) {
	var <int>array lit1 = [43, 43];
	if (currentCode == lit1[literalChar]) {
		literalChar++;
		if (literalChar == 2) {
			if (true) {

var string castac1 = data[""];
var map actionCap1exp = data["exp"];dataStore["data"]["type"] = "one_or_more_raw";
dataStore["data"]["expression"] = actionCap1exp;
dataStore["data"]["location"] = false;
}
			c = 0 - 1;
			literalChar = 0;
}
			this.error.vested++;
	}else{
		this.giveError(1, "" + this.assembleCodes(lit1) + "", currentChar);
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Optional(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	

			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <map>CarpegNativeParserOutput ruleOut0 = this.Simple_Expression(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "Simple_Expression(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var map ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast0;
		c = 1;
		this.error.vested++;
	}
}else if (c == 1) {
	if (currentCode == 63) {
			if (true) {

var string castac1 = data[""];
var map actionCap1exp = data["exp"];dataStore["data"]["type"] = "optional";
dataStore["data"]["expression"] = actionCap1exp;
dataStore["data"]["location"] = false;
}
			c = 0 - 1;
			this.error.vested++;
	}else{
		this.giveError(1, "?", currentChar);
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Not(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	

			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	if (currentCode == 33) {
			
			c = 1;
			this.error.vested++;
	}else{
		this.giveError(1, "!", currentChar);
	}
}else if (c == 1) {
	var <map>CarpegNativeParserOutput ruleOut1 = this.Simple_Expression(input, charPos);
	
if (ruleOut1.hadError) {
		this.giveError(ruleOut1.error.code, "Simple_Expression(" + ruleOut1.error.expected + ")", ruleOut1.error.found);
		
	}else{
		var map ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast1;if (true) {

var map castacexp1 = data["exp"];
var map actionCap1exp = data["exp"];dataStore["data"]["type"] = "simple_not";
dataStore["data"]["expression"] = actionCap1exp;
dataStore["data"]["location"] = false;
}
		c = 0 - 1;
		this.error.vested++;
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<string>CarpegNativeParserOutput>function _(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new string();
dataStore["temp"] = new map();
	var <string>array data = dataStore["temp"];
	var int c = 0;
	data = new <string>array();

			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var bool passed0 = false;
	if (currentCode == 32) {passed0 = true;}else if (currentCode == 9) {passed0 = true;}else if (currentCode == 13) {passed0 = true;}else if (currentCode == 10) {passed0 = true;}
	if (passed0 == false) {
		
	}
	if (passed0) {
		
c = 0;		this.error.vested++;

	}else{
		c = 0 - 1; charPos--; this.offset--;
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <string>CarpegNativeParserOutput parseOutput = new <string>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<string>CarpegNativeParserOutput>function __(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new string();
dataStore["temp"] = new map();
	var string data = dataStore["temp"];
	var int c = 0;
	data["w"] = new <string>array();

			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var bool passed0 = false;
	if (currentCode == 32) {passed0 = true;}else if (currentCode == 9) {passed0 = true;}else if (currentCode == 13) {passed0 = true;}else if (currentCode == 10) {passed0 = true;}
	if (passed0 == false) {
		
	}
	if (passed0) {
		var <string>array castw0 = data["w"];
castw0.push(currentChar);

c = 0;		this.error.vested++;

	}else{
		var <string>array castw0 = data["w"];
if (castw0.length() >= 1) {
c = 0 - 1; charPos--; this.offset--;}else{
this.giveError(1, " , 	, 
, 
", currentChar);}

	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <string>CarpegNativeParserOutput parseOutput = new <string>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<string>CarpegNativeParserOutput>function String(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new string();
dataStore["temp"] = new map();
	var string data = dataStore["temp"];
	var int c = 0;
	
			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <string>CarpegNativeParserOutput ruleOut0 = this.String_Double(input, charPos);
	
if (ruleOut0.hadError) {
		c = 1; charPos--; this.offset--;
		
	}else{
		var string ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		data["str"] = ruleOutCast0;if (true) {

var map castacstr0 = data["str"];
var map actionCap0str = data["str"];dataStore["data"] = actionCap0str;}
		c = 0 - 1;
		this.error.vested++;
	}
}else if (c == 1) {
	var <string>CarpegNativeParserOutput ruleOut1 = this.String_Single(input, charPos);
	
if (ruleOut1.hadError) {
		this.giveError(1, "String_Double, String_Single", currentChar);
		
	}else{
		var string ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		data["str"] = ruleOutCast1;if (true) {

var map castacstr0 = data["str"];
var map actionCap0str = data["str"];dataStore["data"] = actionCap0str;}
		c = 0 - 1;
		this.error.vested++;
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <string>CarpegNativeParserOutput parseOutput = new <string>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<string>CarpegNativeParserOutput>function String_Double(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new string();
dataStore["temp"] = new map();
	var string data = dataStore["temp"];
	var int c = 0;
	
data["str"] = new string();


		
var bool escaped = false;
var map escapeCodes = new map();
escapeCodes["n"] = "\n";
escapeCodes["b"] = "\b";
escapeCodes["f"] = "\f";
escapeCodes["r"] = "\r";
escapeCodes["t"] = "\t";
escapeCodes["v"] = "\v";
escapeCodes["\\"] = "\\";
	var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	if (currentCode == 34) {
			
			c = 1;
			this.error.vested++;
	}else{
		this.giveError(1, "\"", currentChar);
	}
}else if (c == 1) {
	var string castnacstr1 = data["str"];
	
	

var bool doCapture = true;

if (currentChar == "\\") {if (escaped == false) {escaped = true; doCapture = false;}}

if (currentChar == "\"") {
  if (escaped == false) {
    doCapture = false;
    c = 2; charPos--; this.offset--;
  }
  escaped = false;
}else if (escaped and doCapture == true) {
  doCapture = false;
  data["str"] += escapeCodes[currentChar];

  escaped = false;
}

if (doCapture) {
  data["str"] += currentChar;

}


}else if (c == 2) {
	if (currentCode == 34) {
			if (true) {

var string castac2 = data[""];
var string actionCap2str = data["str"];dataStore["data"] = actionCap2str;}
			c = 0 - 1;
			this.error.vested++;
	}else{
		this.giveError(1, "\"", currentChar);
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <string>CarpegNativeParserOutput parseOutput = new <string>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<string>CarpegNativeParserOutput>function String_Single(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new string();
dataStore["temp"] = new map();
	var string data = dataStore["temp"];
	var int c = 0;
	
data["str"] = new string();


		
var bool escaped = false;
var map escapeCodes = new map();
escapeCodes["n"] = "\n";
escapeCodes["b"] = "\b";
escapeCodes["f"] = "\f";
escapeCodes["r"] = "\r";
escapeCodes["t"] = "\t";
escapeCodes["v"] = "\v";
escapeCodes["\\"] = "\\";
	var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	if (currentCode == 39) {
			
			c = 1;
			this.error.vested++;
	}else{
		this.giveError(1, "'", currentChar);
	}
}else if (c == 1) {
	var string castnacstr1 = data["str"];
	
	

var bool doCapture = true;

if (currentChar == "\\") {if (escaped == false) {escaped = true; doCapture = false;}}

if (currentChar == "'") {
  if (escaped == false) {
    doCapture = false;
    c = 2; charPos--; this.offset--;
  }
  escaped = false;
}else if (escaped and doCapture == true) {
  doCapture = false;
  data["str"] += escapeCodes[currentChar];

  escaped = false;
}

if (doCapture) {
  data["str"] += currentChar;

}


}else if (c == 2) {
	if (currentCode == 39) {
			if (true) {

var string castac2 = data[""];
var string actionCap2str = data["str"];dataStore["data"] = actionCap2str;}
			c = 0 - 1;
			this.error.vested++;
	}else{
		this.giveError(1, "'", currentChar);
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <string>CarpegNativeParserOutput parseOutput = new <string>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Json(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	

data["keys"] = new <map>array();
var map captureRoot1 = new map();









			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	if (currentCode == 123) {
			
			c = 1;
			this.error.vested++;
	}else{
		this.giveError(1, "{", currentChar);
	}
}else if (c == 1) {
	var <string>CarpegNativeParserOutput ruleOut1 = this._(input, charPos);
	
if (ruleOut1.hadError) {
		this.giveError(ruleOut1.error.code, "White space(optional)(" + ruleOut1.error.expected + ")", ruleOut1.error.found);
		
	}else{
		var string ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		
		c = 2;
		
	}
}else if (c == 2) {
	var <string>CarpegNativeParserOutput ruleOut2 = this._(input, charPos);
	
if (ruleOut2.hadError) {
		c = 9; charPos--; this.offset--;
		
	}else{
		var string ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		
		c = 3;
		
	}
}else if (c == 3) {
	var <string>CarpegNativeParserOutput ruleOut3 = this.String(input, charPos);
	
if (ruleOut3.hadError) {
		this.giveError(ruleOut3.error.code, "String(" + ruleOut3.error.expected + ")", ruleOut3.error.found);
		
	}else{
		var string ruleOutCast3 = ruleOut3.data["data"];
charPos = this.offset;
		captureRoot1["key"] = ruleOutCast3;
		c = 4;
		this.error.vested++;
	}
}else if (c == 4) {
	var <string>CarpegNativeParserOutput ruleOut4 = this._(input, charPos);
	
if (ruleOut4.hadError) {
		this.giveError(ruleOut4.error.code, "White space(optional)(" + ruleOut4.error.expected + ")", ruleOut4.error.found);
		
	}else{
		var string ruleOutCast4 = ruleOut4.data["data"];
charPos = this.offset;
		
		c = 5;
		
	}
}else if (c == 5) {
	if (currentCode == 58) {
			
			c = 6;
			this.error.vested++;
	}else{
		this.giveError(1, ":", currentChar);
	}
}else if (c == 6) {
	var <string>CarpegNativeParserOutput ruleOut6 = this._(input, charPos);
	
if (ruleOut6.hadError) {
		this.giveError(ruleOut6.error.code, "White space(optional)(" + ruleOut6.error.expected + ")", ruleOut6.error.found);
		
	}else{
		var string ruleOutCast6 = ruleOut6.data["data"];
charPos = this.offset;
		
		c = 7;
		
	}
}else if (c == 7) {
	var <int>CarpegNativeParserOutput ruleOut7 = this.Json_Value(input, charPos);
	
if (ruleOut7.hadError) {
		this.giveError(ruleOut7.error.code, "Json_Value(" + ruleOut7.error.expected + ")", ruleOut7.error.found);
		
	}else{
		var int ruleOutCast7 = ruleOut7.data["data"];
charPos = this.offset;
		captureRoot1["val"] = ruleOutCast7;
		c = 8;
		this.error.vested++;
	}
}else if (c == 8) {
	var <string>CarpegNativeParserOutput ruleOut8 = this._(input, charPos);
	
if (ruleOut8.hadError) {
		c = 9; charPos--; this.offset--;
		
	}else{
		var string ruleOutCast8 = ruleOut8.data["data"];
charPos = this.offset;
		var <map>array castkeys2 = data["keys"];
castkeys2.push(captureRoot1);
if (input.charCodeAt(charPos + 1) != 44) {
c = 9;continue;}else {charPos++;}if (charPos == input.length() - 1) {this.giveError(2, "EOF", currentChar);}
captureRoot1 = new map();







		c = 2;
		
	}
}else if (c == 9) {
	var <string>CarpegNativeParserOutput ruleOut9 = this._(input, charPos);
	
if (ruleOut9.hadError) {
		this.giveError(ruleOut9.error.code, "White space(optional)(" + ruleOut9.error.expected + ")", ruleOut9.error.found);
		
	}else{
		var string ruleOutCast9 = ruleOut9.data["data"];
charPos = this.offset;
		
		c = 10;
		
	}
}else if (c == 10) {
	if (currentCode == 125) {
			if (true) {

var string castac10 = data[""];
var <map>array actionCap10keys = data["keys"];
for (var int i in actionCap10keys) {
    var map k = actionCap10keys[i];
    var string key = k["key"];
    dataStore["data"][key] = k["val"];
}}
			c = 0 - 1;
			this.error.vested++;
	}else{
		this.giveError(1, "}", currentChar);
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Json_Array(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	

data["vals"] = new <int>array();



			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	if (currentCode == 91) {
			
			c = 1;
			this.error.vested++;
	}else{
		this.giveError(1, "[", currentChar);
	}
}else if (c == 1) {
	var <string>CarpegNativeParserOutput ruleOut1 = this._(input, charPos);
	
if (ruleOut1.hadError) {
		this.giveError(ruleOut1.error.code, "White space(optional)(" + ruleOut1.error.expected + ")", ruleOut1.error.found);
		
	}else{
		var string ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		
		c = 2;
		
	}
}else if (c == 2) {
	var <int>CarpegNativeParserOutput ruleOut2 = this.Json_Value(input, charPos);
	
if (ruleOut2.hadError) {
		c = 3; charPos--; this.offset--;
		if (ruleOut2.error.vested > 1) {this.giveError(ruleOut2.error.code, ruleOut2.error.expected, ruleOut2.error.found);}
	}else{
		var int ruleOutCast2 = ruleOut2.data["data"];
charPos = this.offset;
		var <int>array castvals2 = data["vals"];
castvals2.push(ruleOutCast2);
if (input.charCodeAt(charPos + 1) != 44) {
c = 3;continue;}else {charPos++;}if (charPos == input.length() - 1) {this.giveError(2, "EOF", currentChar);}

		c = 2;
		this.error.vested++;
	}
}else if (c == 3) {
	var <string>CarpegNativeParserOutput ruleOut3 = this._(input, charPos);
	
if (ruleOut3.hadError) {
		this.giveError(ruleOut3.error.code, "White space(optional)(" + ruleOut3.error.expected + ")", ruleOut3.error.found);
		
	}else{
		var string ruleOutCast3 = ruleOut3.data["data"];
charPos = this.offset;
		
		c = 4;
		
	}
}else if (c == 4) {
	if (currentCode == 93) {
			if (true) {

var string castac4 = data[""];
var <int>array actionCap4vals = data["vals"];dataStore["data"] = actionCap4vals;}
			c = 0 - 1;
			this.error.vested++;
	}else{
		this.giveError(1, "]", currentChar);
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<<map>array>CarpegNativeParserOutput>function Json_EmptyArray(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new <map>array();
dataStore["temp"] = new map();
	var <map>array data = dataStore["temp"];
	var int c = 0;
	


			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	if (currentCode == 91) {
			
			c = 1;
			this.error.vested++;
	}else{
		this.giveError(1, "[", currentChar);
	}
}else if (c == 1) {
	var <string>CarpegNativeParserOutput ruleOut1 = this._(input, charPos);
	
if (ruleOut1.hadError) {
		this.giveError(ruleOut1.error.code, "White space(optional)(" + ruleOut1.error.expected + ")", ruleOut1.error.found);
		
	}else{
		var string ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		
		c = 2;
		
	}
}else if (c == 2) {
	if (currentCode == 93) {
			if (true) {

var string castac2 = data[""];
data = new <map>array();}
			c = 0 - 1;
			this.error.vested++;
	}else{
		this.giveError(1, "]", currentChar);
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <<map>array>CarpegNativeParserOutput parseOutput = new <<map>array>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<map>CarpegNativeParserOutput>function Json_EmptyMap(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new map();
dataStore["temp"] = new map();
	var map data = dataStore["temp"];
	var int c = 0;
	


			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	if (currentCode == 123) {
			
			c = 1;
			this.error.vested++;
	}else{
		this.giveError(1, "{", currentChar);
	}
}else if (c == 1) {
	var <string>CarpegNativeParserOutput ruleOut1 = this._(input, charPos);
	
if (ruleOut1.hadError) {
		this.giveError(ruleOut1.error.code, "White space(optional)(" + ruleOut1.error.expected + ")", ruleOut1.error.found);
		
	}else{
		var string ruleOutCast1 = ruleOut1.data["data"];
charPos = this.offset;
		
		c = 2;
		
	}
}else if (c == 2) {
	if (currentCode == 125) {
			if (true) {

var string castac2 = data[""];
data = new map();}
			c = 0 - 1;
			this.error.vested++;
	}else{
		this.giveError(1, "}", currentChar);
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <map>CarpegNativeParserOutput parseOutput = new <map>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<int>CarpegNativeParserOutput>function Json_Value(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new int();
dataStore["temp"] = new map();
	var int data = dataStore["temp"];
	var int c = 0;
	


			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var <string>CarpegNativeParserOutput ruleOut0 = this._(input, charPos);
	
if (ruleOut0.hadError) {
		this.giveError(ruleOut0.error.code, "White space(optional)(" + ruleOut0.error.expected + ")", ruleOut0.error.found);
		
	}else{
		var string ruleOutCast0 = ruleOut0.data["data"];
charPos = this.offset;
		
		c = 1;
		
	}
}else if (c == 1) {
	var <int>array lit1 = [110, 117, 108, 108];
	if (currentCode == lit1[literalChar]) {
		literalChar++;
		if (literalChar == 4) {
			if (true) {

var string castacexp1 = data["exp"];
data["exp"] = empty;}
			c = 10;
			literalChar = 0;
}
			this.error.vested++;
	}else{
		c = 2; charPos--; this.offset--;
	}
}else if (c == 2) {
	var <int>array lit2 = [116, 114, 117, 101];
	if (currentCode == lit2[literalChar]) {
		literalChar++;
		if (literalChar == 4) {
			if (true) {

var string castacexp2 = data["exp"];
data["exp"] = true;}
			c = 10;
			literalChar = 0;
}
			this.error.vested++;
	}else{
		c = 3; charPos--; this.offset--;
	}
}else if (c == 3) {
	var <int>array lit3 = [102, 97, 108, 115, 101];
	if (currentCode == lit3[literalChar]) {
		literalChar++;
		if (literalChar == 5) {
			if (true) {

var string castacexp3 = data["exp"];
data["exp"] = false;}
			c = 10;
			literalChar = 0;
}
			this.error.vested++;
	}else{
		c = 4; charPos--; this.offset--;
	}
}else if (c == 4) {
	var <<map>array>CarpegNativeParserOutput ruleOut4 = this.Json_EmptyArray(input, charPos);
	
if (ruleOut4.hadError) {
		c = 5; charPos--; this.offset--;
		
	}else{
		var <map>array ruleOutCast4 = ruleOut4.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast4;
		c = 10;
		this.error.vested++;
	}
}else if (c == 5) {
	var <map>CarpegNativeParserOutput ruleOut5 = this.Json_EmptyMap(input, charPos);
	
if (ruleOut5.hadError) {
		c = 6; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast5 = ruleOut5.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast5;
		c = 10;
		this.error.vested++;
	}
}else if (c == 6) {
	var <map>CarpegNativeParserOutput ruleOut6 = this.Json_Array(input, charPos);
	
if (ruleOut6.hadError) {
		c = 7; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast6 = ruleOut6.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast6;
		c = 10;
		this.error.vested++;
	}
}else if (c == 7) {
	var <map>CarpegNativeParserOutput ruleOut7 = this.Json(input, charPos);
	
if (ruleOut7.hadError) {
		c = 8; charPos--; this.offset--;
		
	}else{
		var map ruleOutCast7 = ruleOut7.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast7;
		c = 10;
		this.error.vested++;
	}
}else if (c == 8) {
	var <string>CarpegNativeParserOutput ruleOut8 = this.String(input, charPos);
	
if (ruleOut8.hadError) {
		c = 9; charPos--; this.offset--;
		
	}else{
		var string ruleOutCast8 = ruleOut8.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast8;
		c = 10;
		this.error.vested++;
	}
}else if (c == 9) {
	var <int>CarpegNativeParserOutput ruleOut9 = this.Json_Number(input, charPos);
	
if (ruleOut9.hadError) {
		this.giveError(1, "null, true, false, Json_EmptyArray, Json_EmptyMap, Json_Array, Json, String, Json_Number", currentChar);
		
	}else{
		var int ruleOutCast9 = ruleOut9.data["data"];
charPos = this.offset;
		data["exp"] = ruleOutCast9;
		c = 10;
		
	}
}else if (c == 10) {
	var <string>CarpegNativeParserOutput ruleOut10 = this._(input, charPos);
	
if (ruleOut10.hadError) {
		this.giveError(ruleOut10.error.code, "White space(optional)(" + ruleOut10.error.expected + ")", ruleOut10.error.found);
		
	}else{
		var string ruleOutCast10 = ruleOut10.data["data"];
charPos = this.offset;
		if (true) {

var string castac10 = data[""];
var map actionCap10exp = data["exp"];dataStore["data"] = actionCap10exp;}
		c = 0 - 1;
		
	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <int>CarpegNativeParserOutput parseOutput = new <int>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
bound public <<int>CarpegNativeParserOutput>function Json_Number(string input, int startPos) {var int oldVest = this.error.vested;
	var map dataStore = new map();
dataStore["data"] = new int();
dataStore["temp"] = new map();
	var int data = dataStore["temp"];
	var int c = 0;
	data["nums"] = new string();

			var int literalChar = 0;
	for (var int charPos = startPos; charPos < input.length(); charPos++) {
		var string currentChar = input[charPos];
		var int currentCode = input.charCodeAt(charPos);
		if (currentCode == 10) {this.line++; this.column = 0;}
		if (c == 0) {
	var bool passed0 = false;
	if (currentCode == 46) {passed0 = true;}else if (currentCode == 45) {passed0 = true;}
	if (passed0 == false) {
		if (int.mid(currentCode, 48, 57)) {passed0 = true;}
	}
	if (passed0) {
		data["nums"] += currentChar;
if (true) {

var string castacnums0 = data["nums"];
var string actionCap0nums = data["nums"];dataStore["data"] = string.parseInt(actionCap0nums);}
c = 0;		this.error.vested++;

	}else{
		var string castnums0 = data["nums"];
if (castnums0.length() >= 1) {
if (true) {

var string castacnums0 = data["nums"];
var string actionCap0nums = data["nums"];dataStore["data"] = string.parseInt(actionCap0nums);}c = 0 - 1; charPos--; this.offset--;}else{
this.giveError(1, "0-9, ., -", currentChar);}

	}
}		this.offset++; this.column++;
		if (c == 0 - 1) {this.offset = charPos; break;}
		if (this.hadError) {break;}
	}
	var <int>CarpegNativeParserOutput parseOutput = new <int>CarpegNativeParserOutput(this.hadError, this.error.clone(), dataStore);
	parseOutput.error.vested = this.error.vested - oldVest; this.error.vested = oldVest;	this.hadError = false;
	return parseOutput;
}
}